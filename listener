#!/bin/bash
source config 2>/dev/null

# Go to end-sequence on CTRL-C
trap rollcredits SIGINT SIGTERM

##
## Declare functions
##

# Various messages
lineprint()
{
    printf -- "\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"
}

saygoodbye()
{
    sleep 1s;
    lineprint
    printf "${BLUE}bye${NC}!"
    lineprint
}

# Inform user of script re-run
loop_end_message()
{
    sleep 2s;
            printf "${BLUE}listening once more${NC} ☜(ﾟヮﾟ☜)!\n"
            echo "- - - - - - - - - - - - - - - - - - - - - -"
            echo "- - - - - - N E W       J O B - - - - - - -"
            echo "- - - - - - - - - - - - - - - - - - - - - -"
}

# VERY basic sanity checks ... config provided? WORKDIR defined? STREAM defined?
basicsanity()
{
    if [ ! -f ./config ]; then
        lineprint
        printf "${BLUE}N O   C O N F I G   F O U N D${NC}!   » » »   S E E   ${BLUE}R E A D M E . m d ${NC}"
        lineprint
        exit 2;
    fi

    if [ -z "$WORKDIR" ]; then
        lineprint
        printf "P L E A S E   ${BLUE}D E F I N E   W O R K D I R${NC}   I N   ${BLUE}. / C O N F I G${NC}"
        lineprint
        exit 2;
    fi

    if [ -z "$STREAM" ]; then
        lineprint
        printf "P L E A S E   ${BLUE}D E F I N E   S T R E A M${NC}   I N   ${BLUE}. / C O N F I G${NC}"
        lineprint
        exit 2;
    fi
}

# Remove 0byte files recursively inside WORKDIR
cleanup_0byte()
{
    find . -type f \( -not -name "ffmpeg.log" \) -size 0 -print0 | xargs -I{} -0 rm {};
}

# Log output to console
log_encoder()
{
    lineprint
    printf "${BLUE}ffmpeg${NC} log:"
    lineprint
    tail -F -n 10 $LOGDIR/ffmpeg.log 2>/dev/null;
}

log_listener()
{
    lineprint
    printf "${BLUE}streamlink${NC} log:"
    lineprint
    printf "\n"
    tail -F $LOGDIR/$DATE.log 2>/dev/null &
}

# End log output to console
kill_log_encoder()
{
    kill $(pgrep -f "^(tail -F.*$LOGDIR/ffmpeg.log).*$") 2>/dev/null
}

kill_log_listener()
{
    kill $(pgrep -f "^(tail -F.*$LOGDIR/$DATE).*$") 2>/dev/null
}


# End-sequence
rollcredits()
{
    kill_log_listener;
    runjobs;
    log_encoder;
    menu;
}

# Exit screen
menu()
{
    trap menu SIGINT SIGTERM
    lineprint
    printf "Do you want to ${BLUE}kill the scheduler${NC}?"
    lineprint
    printf "${BLUE}[warning!]${NC} this will also ${BLUE}kill pending jobs${NC}!"
    lineprint
    kill_log_encoder;
    select yn in "Yes" "No" "Show Log"; do
        case $yn in
            Yes ) kill_log_encoder; killjobs; pkill scheduler; saygoodbye; exit 0;;
            No ) saygoodbye; exit 0;;
            Show\ Log ) log_encoder; menu;;
        esac
    done
}

# FFMPEG queue pipe
runscheduler()
{
    if ! pgrep -x "scheduler" > /dev/null
        then
            setsid nohup ./scheduler >/dev/null 2>&1 &
            printf "\n\n${BLUE}ffmpeg-scheduler${NC} started ${BLUE}in background.${NC}\n"
        else
            printf "\n\n${BLUE}ffmpeg-scheduler${NC} already running.${NC}\n"
    fi
}

# Provide timestamp per job
timestamp()
{
    DATE="$(date +%m_%d_%Y-%H:%M:%S-%s)"
    printf "\n\nwill write to ${BLUE}"$DATE"${NC}.mp4\n";
}

# Streamlink
streamlink_listen()
{
    if [ -z "$PLAYER" ];
            then
                lineprint
                printf -- "- - - - - R U N N I N G   I N   ${BLUE}H E A D L E S S   M O D E${NC} - - - - -"
                lineprint

                streamlink $STREAM -o src/$DATE.mp4 > $LOGDIR/$DATE.log 2>&1;
            else
                streamlink $STREAM -O 2>> $LOGDIR/$DATE.log | tee src/$DATE.mp4 | $PLAYER - $PLAYER_OPTIONS >> $LOGDIR/$DATE.log 2>&1;
    fi
}

# Send jobs to FFMPEG queue
runjobs()
{
    cleanup_0byte;
    setsid nohup ./transcoder > /dev/null 2>&1 &
    lineprint
    printf "${BLUE}sent jobs${NC} for ${BLUE}$DATE${NC}.mp4 to scheduler!"
    lineprint
}

# Kill a running FFMPEG job
killjobs()
{
    kill $(pgrep -f "^(ffmpeg -y -i.*.mp4.-hide_banner).*$") >/dev/null 2>&1 &
}

# That main-function really tied the room together.
main()
{
    while true; do
        cd $WORKDIR
        timestamp;
        log_listener;
        streamlink_listen;
        runjobs;
        loop_end_message;
    done
}

##
## Roll the script!
##
basicsanity;
runscheduler;
main
